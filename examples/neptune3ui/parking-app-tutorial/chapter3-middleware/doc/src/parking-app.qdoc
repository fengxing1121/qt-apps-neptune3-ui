/****************************************************************************
**
** Copyright (C) 2019 Luxoft Sweden AB
** Contact: https://www.qt.io/licensing/
**
** This file is part of the documentation of the Neptune module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL-QTAS$
** Commercial License Usage
** Licensees holding valid commercial Qt Automotive Suite licenses may use
** this file in accordance with the commercial license agreement provided
** with the Software or, alternatively, in accordance with the terms
** contained in a written agreement between you and The Qt Company.  For
** licensing terms and conditions see https://www.qt.io/terms-conditions.
** For further information use the contact form at https://www.qt.io/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file. Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: https://www.gnu.org/licenses/fdl-1.3.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
\example neptune3ui/parking-app-tutorial
\brief Provides step-by-step instructions on how to develop a parking app for Neptune 3 UI.
\ingroup neptune3ui-examples
\title Develop a Parking App Step-by-Step
\image parking-app.png

\section1 Introduction

In the previous chapters we already went through the UI and what components need to be used to have
a good integration in the Neptune 3 UI.

This example shows you how to extend the Parking App step-by-step with a Middleware API and provide
a simulation which shows the current number of parking lots.

This tutorial will briefly explain how the Middleware integration works and what needs to be done
to package it up correctly. For a full deep dive on how to develop Middleware APIs please see the
\l{Qt IVI Generator Tutorial}.

\note For this application a multi-process environment is needed.

\section1 Define the Middleware API

To define our Middleware API we will use the IVI Generator from the QtIvi module. The generator
uses a Interface Definition Language (IDL) to generate code. This will reduce the amount of code to
write fundamentally.

\section2 Introduction to QFace

QtIvi uses a IDL called QFace to describe what needs to be generated.

For our example we define a simple interface called "ParkingInfo" which provides a \c readonly
property called "freeLots" inside a module called "Parking".

\snippet ../examples/neptune3ui/parking-app-tutorial/chapter3-middleware/parking.qface

For a deep-dive into what's possible with QFace and the IVI Generator, please check the \l{QFace IDL
Syntax}.

\section1 Autogeneration

Now that our first version of the IDL file is ready, it's time to autogenerate API from it, using
the \l IVI Generator tool. Similar to \l moc, this autogeneration process is integrated into the
qmake Build System and is done on compile time.

In the following .pro file we build a C++ library based on our IDL file:

\snippet ../examples/neptune3ui/parking-app-tutorial/chapter3-middleware/frontend/frontend.pro

By adding \c ivigenerator to the \c CONFIG variable, the ivigenerator qmake integration is loaded
and expects a QFace IDL file in the \c QFACE_SOURCES variable. The set \c DEFINE makes sure that
the library exports it's symbols, which is needed on windows systems.

\section2 Which Files are Autogenerated

The IVI Generator works based on generation templates. These templates define what content
should be generated from a QFace file. If no \c QFACE_FORMAT is defined, this automatically
defaults to "frontend" template. For more details on these templates, see \l{Use the Generator}.

In short, the "frontend" template generates:
\list
    \li a C++ class derived from QIviAbstractFeature for every interface in the QFace file
    \li one module class that helps to register all interfaces to QML and stores global types
        and functions.
\endlist

To inspect the C++ code yourself, you can view these files in the your library's build folder.

\section2 QML plugin

In addition to the library which contains our Middleware API, we also need a QML plugin to be able
to use the API from within QML.

The IVI Generator can also help here, by using a different generation template. The following
pro file generates a qml plugin which exports the API to QML:

\snippet ../examples/neptune3ui/parking-app-tutorial/chapter3-middleware/imports/imports.pro

We use \c CONFIG to build a plugin, then define the settings for the linker to link against our
frontend library. Then, we use \c QFACE_FORMAT to define "qmlplugin" as the generation template.
Instead of adding \c ivigenerator to \c CONFIG, this time we use
\l{https://doc.qt.io/qt-5/qmake-test-function-reference.html#load-feature} {qmake's load()
function} to explicitly load the feature. This enables us to use the \c URI variable which is part
of the "qmlplugin" generation template. This URI can be used to define a \c DESTDIR by replacing
all dots with slashes.

In addition to the folder structure, the QmlEngine also needs a \c qmldir file which indicates what
files are part of the plugin, and under which \c URI. For more information, see
\l{https://doc.qt.io/qt-5/qtqml-modules-qmldir.html}{Module Definition qmldir Files}. Both this \c
qmldir file and a \c plugins.qmltypes file which provides information about code-completion, are
autogenerated by the IVI Generator; but they need to be placed next to the library. To do so, we
add the files to a scope similar to an \c INSTALL target, but add it to the \c COPIES variable
instead. This makes sure that the files are copied when the plugin is built.

\section1 QML integration

After we generated our Middleware API and the QML plugin, it is time to integrate our new API into
the parking app.
For the QML plugin the module name in our IDL file is used as the import uri and by default it uses
\c 1.0 as the import version. The import statement for our main.qml looks like this:

\quotefromfile ../examples/neptune3ui/parking-app-tutorial/chapter3-middleware/app/Main.qml
\skipto import Example
\printuntil import Example

By default the QML API uses the same name than the interface in our IDL file. For more information
on how to use a custom name or import \c URI please see \l{Use the Generator}.
Our interface can now be instantiated and we set a id like any other QML element:

\quotefromfile ../examples/neptune3ui/parking-app-tutorial/chapter3-middleware/app/Main.qml
\skipto ParkingInfo
\printuntil }

To show the currently free parking lots, we need to create a QML binding using the 'freeLots'
property of our newly added \c ParkingInfo QML element:

\quotefromfile ../examples/neptune3ui/parking-app-tutorial/chapter3-middleware/app/Main.qml
\skipto text: parkingInfo
\printuntil "

\section2 Needed Adaptions for Packaging

For a normal Qt QML application, these steps would be enough to start the application now and see
that number of free lots is \c 0 because it is initialized to the default value.
But because we develop a application for the Neptune 3 UI and intend to package it and install it
while Neptune 3 UI is running, additional steps are needed.

\section3 Don't create library symbolic links

Usually when building a library, 2 symbolic links are created to allow version upgrades without
the need to recompile other applications. Inside an ApplicationManager package symbolic links are
not allowed for security reasons. Because of this, the following qmake \c CONFIG needs to be set to
not create those symbolic links and also don't use them while linking to the library:

\badcode
    CONFIG += unversioned_libname unversioned_soname
\endcode

\section3 Define import paths and other additional settings in the info.yaml

For our QML plugin to work, we need to set an additional import path to the qmlengine. Usually
this is done by using the \c QML2_IMPORT_PATH environment variable, passing it to qmlscene or
use QQmlEngine::addImportPath() in your own main. But because the ApplicationManager starts
the application after the installation and we don't package our own main.cpp, we need to define
those settings in the package manifest, the info.yaml. For the import path, we add the following
line:

\code
    runtimeParameters:
        importPaths: [ 'imports' ]
\endcode

With those settings in place, the application can now be deployed and should show \c 0 free
parking lots:

\image first-integration.png

\section1 Define a Simulation Behavior

To simulate some values for our Middleware API, we need to understand the QtIvi architecture
a bit better. As we learned when generating the library a template called 'frontend' is used
by the IVI Generator. To define some simulation values or to connect a real API, we also need
a 'backend'. This 'backend' is provided in form of a plugin and QtIvi takes care to load
and connect the two. For more information, see the \link {Dynamic Backend Architecture}.

\section2 Backend plugin with static values

The next step is to generate such a backend by using the IVI Generator and use annotations
to define what the simulation should do.

Let's start with the pro file to generate and build the backend:

\snippet ../examples/neptune3ui/parking-app-tutorial/chapter3-middleware/backend_simulator/backend_simulator.pro

To build a plugin we need to add 'plugin' to the \c CONFIG variable as well as change the
\c QFACE_FORMAT to 'backend_simulator' to use the correct generation template. Similar to
the QML plugin, the backend also needs to link to our frontend library as its using the
types defined there.

To make sure QtIVI can find the backend, they need to be inside a 'qtivi' folder. This
folder needs to be part of the Qt plugin search path.

Similar to the import path, the additional plugin path needs to setup in the package manifest:

\code
    runtimeParameters:
        pluginPaths: [ '.' ]
\endcode

Now we created a simulation backend, but without additional information, the IVI Generator
cannot create something really useful.

First we define a static default value which should be provided by the simulation backend.
The easiest way is to use an annotation in our QFace IDL file. An annotation is a special
kind of comment which gives the generation template additional information what should
be generated. To define a default value we change the IDL file like this:

\quotefromfile ../examples/neptune3ui/parking-app-tutorial/chapter3-middleware/parking.qface
\skipuntil @config_simulator
\printuntil }
\printuntil }

Because of the change in the IDL file, the IVI Generator will now recreate the backend
plugin and when running the updated application we now should see \c 42 free parking lots.

\section2 Simulation QML

Using the annotation to define a default value is a simple way to provide a static simulation, but
the generated simulation backend can do more and also allows you to define a simulation behavior
in a more dynamic way.

For this we add another annotation to our QFace IDL file and define a "simulationFile". This file
is loaded by the QIviSimulationEngine and contains our simulation behavior. Similar to other QML
files, the best way to serve this file is to embed it inside a Qt resource.

Our simulation.qml looks like this:

\snippet ../examples/neptune3ui/parking-app-tutorial/chapter3-middleware/backend_simulator/simulation.qml

First, there's a \c settings property, that's initialized with the return value from the
\l{IviSimulator::findData}{IviSimulator.findData} method, which takes the
\l{IviSimulator::simulationData}{IviSimulator.simulationData} and a string as input. The
\c simulationData is the JSON file represented as a JavaScript object.

The \c findData method helps us to extract only the data that is of interest for this
interface, \c InstrumentCluster. The properties that follow help the interface to know whether
the default values are set. The \c LoggingCategory is used to identify the log output from this
simulation file.

Afterwards, the actual behavior is defined by instantiating an \c InstrumentClusterBackend Item
and extending it with more functions. The \c InstrumentClusterBackend is the interface towards
our \c InstrumentCluster QML frontend class. But, apart from the frontend, these properties are
also writable to make it possible to change them to provide a useful simulation.

Each time a frontend instance connects to a backend, the \c initialize() function is called.
The same applies to the QML simulation: as the \c initialize() C++ function forwards this to
the QML instance. This also applies to all other functions, like setter and getters, for
properties or methods. For more details, see \l{QIviSimulationEngine}.

Inside the QML \c initialize() function, we call \c{IviSimulator.initializeDefault()}, to read
the default values from the \c simulationData object and initialize all properties. This is
done only \b once, as we don't want the properties be reset to default when the next frontend
instance connects to the backend. Lastly, the base implementation is called to make sure that
the \c initializationDone signal is sent to the frontend.

Next we define the actual simulation behavior by creating a Timer element which triggers every
5 seconds. In the binding to the trigger signal we use the \c{Math.random()} function to get a random
value between -5 and 5 and add this to the available parking lots by using the 'freeLots' property
of our backend. The change of this value gets automatically populated to the frontend and simulates
a real car park.
*/
